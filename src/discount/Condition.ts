import Property from "../core/Property";

/**
 * Описывает шаблон класса для проверки данных. Первый параметр T это класс наследник, который реализует данный класс.
 * Второй параметр U это класс, проверка в котором будет совершаться проверка.
 */
export default class Condition<T extends Condition<T, U>, U> {
  /**
   * Массив екземпляров класса реализации текущего, во время проверки к результату проверки всех будет применяться логическое ИЛИ
   * (если хотя бы один елемент в массиве во время проверки отдал положительный результат, то общий результат тоже считается
   * положительным)
   */
  OR?: T[];
  /**
   * Массив екземпляров класса реализации текущего, во время проверки к результату проверки всех будет применяться логическое И
   * (если хотя бы один елемент в массиве во время проверки отдал отрицательный результат, то общий результат тоже считается
   * отрицательный)
   */
  AND?: T[];
  /**
   * Массив полей для проверки. Тут хранятся пары имя-поля-для-проверки : значение-которому-оно-должно-равняться.
   * Если хотя бы одно из условий тут не выполняется, будет отдан отрицательный результат.
   */
  where?: Property<U>[];

  /**
   *
   * @param where - поля для проверки
   * @param and - другие проверки, к которым применять логическое И
   * @param or - другие проверки, к которым применять логическое ИЛИ
   */
  constructor(where?: Property<U>[], and?: T[], or?: T[]) {
    this.where = where;
    this.AND = and;
    this.OR = or;
  }

  /**
   * Создаёт новый екзеспляр класса наследника, который был передан в эту функцию. Указываются поля для создания класса-
   * наследника и его тип.
   * @param where - поля для проверки
   * @param AND - другие проверки, к которым применять логическое И
   * @param OR - другие проверки, к которым применять логическое ИЛИ
   * @param args - другие поля класса наследника
   * @param type - тип класса наследника. Тут указывается название класса, который следует создать
   */
  protected static buildCondition<T extends Condition<T, U>, U>({where, OR, AND, ...args}: T, type: new(where?: Property<U>[], and?: T[], or?: T[], ...args: any[]) => T): T {
    if (OR)
      OR = OR.map(i => this.buildCondition(i, type));
    if (AND)
      AND = AND.map(i => this.buildCondition(i, type));
    return new type(where, AND, OR, args);
  }

  /**
   * Проверка что некоторый объект соответствует данному условию.
   * Проверка идёт в таком порядке:
   * - проверяются [[where]] посредством логического И, то есть если хотя бы одно поле в переданом объекте не соответствует
   * указаному в [[Property]], будет отказ
   * - проверяются условия внутри поля [[OR]]. Если хотя бы одно условие было выполнено, то функция вернёт успех
   * - проверяются условия внутри поля [[AND]]. Если хотя бы одно условие не было выполнено, то функция вернёт отказ
   * @param checkObject - объект для проверки
   */
  public check(checkObject: U): boolean {
    if (this.where) {
      if (this.where.length) {
        for (let cond of this.where) {
          if (checkObject[cond.property] !== cond.value) {
            return false;
          }
        }
      }
    }

    if (this.OR) {
      if (this.OR.length) {
        for (let cond of this.OR) {
          if (cond.check(checkObject))
            return true;
        }
      }
    }

    if (this.AND) {
      if (this.AND.length) {
        for (let cond of this.AND) {
          if (!cond.check(checkObject))
            return false;
        }
      }
    }

    return true;
  }
}
